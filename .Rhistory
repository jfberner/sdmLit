usethis::use_mit_license()
devtools::load_all()
data(consistency)
data(congruence)
congruency <- raster::raster('data/congruency.grd')
congruence <- raster::raster('data/congruence.grd')
usethis::use_data(congruence, congruence, overwrite = T)
devtools::document()
install.packages('Rdpack')
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
?data
devtools::check()
devtools::document()
warnings()
devtools::document()
warnings()
devtools::document()
warnings()
devtools::document()
warnings()
devtools::check()
devtools::document()
devtools::check()
warnings()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
warnings()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
install.packages('sinew')
sinew::makeOxygen(congruence, add_fields = 'source')
congruence <- raster::raster('inst/extdata/congruence.grd')
data("congruence")
sinew::makeOxygen(congruence, add_fields = 'source')
devtools::document()
devtools::check()
tools::checkRdaFiles()
tools::checkRdaFiles('data/')
usethis::use_data(congruence,congruence,overwrite = T,compress = bzip2)
usethis::use_data(congruence,congruence,overwrite = T)
devtools::document()
devtools::check()
View(congruence)
library(raster)
congruence
teste <- raster('inst/extdata/congruence.grd')
teste
teste <- raster('inst/extdata/congruence.grd',crs=T)
teste
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
remotes::install_github('jfberner/sdmTools')
library(sdmTools)
remotes::install_github('jfberner/sdmTools')
library(sdmTools)
usethis::use_readme_rmd()
remotes::install_github('jfberner/sdmTools')
library(sdmTools)
remove.packages('sdmTools')
remotes::install_github('jfberner/sdmTools')
library(sdmTools)
paths <- readRDS("~/R/x86_64-pc-linux-gnu-library/4.2/sdmTools/help/paths.rds")
devtools::document()
remove.packages('sdmTools')
remotes::install_github('jfberner/sdmTools')
library(sdmTools)
devtools::document()
remove.packages('sdmTools')
remotes::install_github('jfberner/sdmTools')
library(sdmTools)
devtools::document()
remotes::install_github('jfberner/sdmTools')
devtools::document()
remotes::install_github('jfberner/sdmTools')
library(sdmTools)
devtools::document()
remotes::install_github('jfberner/sdmTools')
help(sdmTOols)
help(sdmTools)
devtools::document()
remotes::install_github('jfberner/sdmTools')
install.packages('ecospat')
install.packages('ks')
install.packages(c("cli", "dismo", "ggridges", "httr2", "igraph", "mnormt", "pracma", "raster", "rgl", "rlang", "tinytex", "tokenizers", "webshot"))
install.packages('ecospat')
install.packages('misc3d')
install.packages('ecospat')
sdm_to_boyceIndex <- function(preds, layer, occurence, ...){
fit <- preds[[layer]]
obs <- occurrence
x <- ecospat::ecospat.boyce(fit = fit, obs = obs, PEplot = T, ...)
return(x)
}
occ_train <- rgdal::readOGR('data/processed/shapefiles/train.shp')
pred_pres <- terra::rast(x = 'data/processed/model-build/predictions/predictions.present-all-algorithms.tif') # remember to read with terra:: to retain layer names
pred_pres <- raster::stack(pred_pres) # and then turn them into RasterStacks
# Libs #####
library(raster)
sdm_to_boyceIndex <- function(preds, layer, occurence, ...){
fit <- preds[[layer]]
obs <- occurrence
x <- ecospat::ecospat.boyce(fit = fit, obs = obs, PEplot = T, ...)
return(x)
}
teste <- sdm_to_boyceIndex(pred_pres, 1, occ_train)
sdm_to_boyceIndex <- function(preds, layer, occurrence, ...){
fit <- preds[[layer]]
obs <- occurrence
x <- ecospat::ecospat.boyce(fit = fit, obs = obs, PEplot = T, ...)
return(x)
}
teste <- sdm_to_boyceIndex(pred_pres, 1, occ_train)
occ_test <- rgdal::readOGR('data/processed/shapefiles/test.shp')
ecospat::ecospat.boyce(pred_pres[[1]], occ_train)
pred_pres[[1]]
sdm_to_boyceIndex <- function(preds, layer, occurrence, ...){
fit <- preds[[layer]]
obs <- as.data.frame(occurrence)
x <- ecospat::ecospat.boyce(fit = fit, obs = obs, PEplot = T, ...)
return(x)
}
teste <- sdm_to_boyceIndex(pred_pres, 1, occ_train)
occurrence <- as.data.frame(occ_test)
occurrence
sdm_to_boyceIndex <- function(preds, layer, occurrence, ...){
fit <- preds[[layer]]
obs <- as.data.frame(occurrence)[,2:3]
x <- ecospat::ecospat.boyce(fit = fit, obs = obs, PEplot = T, ...)
return(x)
}
teste <- sdm_to_boyceIndex(pred_pres, 1, occ_train)
teste
teste <- sdm_to_boyceIndex(pred_pres, 2, occ_train)
teste <- sdm_to_boyceIndex(pred_pres, mean(2:5), occ_train)
#'
#' @param preds
#' @param layer
#' @param occurrence
#' @param ...
#'
#' @return
#' @export
#'
#' @examples
sdm_to_boyceIndex <- function(preds, layer, occurrence, ...){
fit <- preds[[layer]]
if (class(occurrence) == "SpatialPointsDataFrame") {
obs <- as.data.frame(occurrence)[,2:3]
}
else obs <- occurrence
x <- ecospat::ecospat.boyce(fit = fit, obs = obs, PEplot = T, ...)
return(x)
}
teste <- sdm_to_boyceIndex(pred_pres, mean(2:5), occ_train)
teste <- sdm_to_boyceIndex(pred_pres, mean(2:5), occurrence[,2:3])
class(occurrence)
teste
devtools::document()
remotes::install_github('jfberner/sdmTools')
occ_test
occ_train
occ_test
# The following are shapefiles (.shp) being loaded:
occ_train <- rgdal::readOGR('data/processed/shapefiles/train.shp')
occ_test <- rgdal::readOGR('data/processed/shapefiles/test.shp')
occ_train
occ_test
class(occ_train)
class(envpres)
envpres <- dir(path = 'data/processed/envcropped/Present/', pattern = ".tif$", full.names = T)
envpres <- raster::stack(envpres)
class(envpres)
str(knitr::opts_chunk$get())
devtools::document()
devtools::install_github('jfberner/sdmTools')
data("congruence")
plot(congruence)
library(raster)
plot(congruence)
congruence <- raster::raster('/inst/extdata/congruence.grd')
congruence <- raster::raster('inst/extdata/congruence.grd')
usethis::use_data(congruence,congruence,overwrite = T)
devtools::document()
warnings()
devtools::install_github('jfberner/sdmTools')
library(sdmTools)
devtools::document()
devtools::load_all()
?sdm_to_boyceIndex()
?sdm_to_boyceIndex
devtools::load_all()
help(sdm_to_boyceIndex = sdmTools)
library(sdmTools)
devtools::document()
warnings()
library(sdmTools)
data("congruence")
library(raster)
plot(congruence)
pocc <- terra::rast(x = 'data/processed/model-build/predictions/predictions.present-all-algorithms.tif') # remember to read with terra:: to retain layer names
pocc <- raster::stack(pocc) # and then turn them into RasterStacks
m_occ <- sdm::read.sdm("data/processed/model-build/model-object/model.sdm")
sdm_to_consistency(pocc,1)
data("congruence")
library(raster)
data("congruence")
force(congruence)
library(sdmTools)
sdmTools::sdm_to_consistency(pocc,1)
raster::raster(data("congruence"))
force(congruence)
force(raster::raster(data("congruence")))
force(congruence)
devtools::document()
library(sdmTools)
pocc <- terra::rast(x = 'data/processed/model-build/predictions/predictions.present-all-algorithms.tif') # remember to read with terra:: to retain layer names
pocc <- raster::stack(pocc) # and then turn them into RasterStacks
m_occ <- sdm::read.sdm("data/processed/model-build/model-object/model.sdm")
sdmTools::sdm_to_consistency(pocc,1)
data("congruence")
raster::plot(congruence)
data("congruence")
?congruence
usethis::use_data(congruence,congruence,overwrite = T,compress = bzip2)
usethis::use_data(congruence,congruence,overwrite = T)
congruence
data("congruence")
congruence <- sdmTools::congruence
library(sdmTools)
pocc <- terra::rast(x = 'data/processed/model-build/predictions/predictions.present-all-algorithms.tif') # remember to read with terra:: to retain layer names
pocc <- raster::stack(pocc) # and then turn them into RasterStacks
m_occ <- sdm::read.sdm("data/processed/model-build/model-object/model.sdm")
sdm_to_consistency(pocc,1)
suitability <- pocc[[1]]
congruencer<-resample(x=congruence, y=suitability, method="bilinear")
plot(congruencet)
plot(congruencer)
colmat<-function(nquantiles=10, upperleft="#be64ac", upperright="#3b4994", bottomleft="#e8e8e8", bottomright="#5ac8c8", xlab="x label", ylab="y label"){
my.data<-seq(0,1,.01)
my.class<-classIntervals(my.data,n=nquantiles,style="quantile")
my.pal.1<-findColours(my.class,c(upperleft,bottomleft))
my.pal.2<-findColours(my.class,c(upperright, bottomright))
col.matrix<-matrix(nrow = 101, ncol = 101, NA)
for(i in 1:101){
my.col<-c(paste(my.pal.1[i]),paste(my.pal.2[i]))
col.matrix[102-i,]<-findColours(my.class,my.col)}
plot(c(1,1),pch=19,col=my.pal.1, cex=0.5,xlim=c(0,1),ylim=c(0,1),frame.plot=F, xlab=xlab, ylab=ylab,cex.lab=1.3)
for(i in 1:101){
col.temp<-col.matrix[i-1,]
points(my.data,rep((i-1)/100,101),pch=15,col=col.temp, cex=1)}
seqs<-seq(0,100,(100/nquantiles))
seqs[1]<-1
col.matrix<-col.matrix[c(seqs), c(seqs)]}
# Get colour matrix with 5 quantiles and legend. Specify the number of quantiles, colours and   # labels of the colour legend.
col.matrix<-colmat(nquantiles=5,
upperleft="#be64ac",
upperright="#3b4994",
bottomleft="#e8e8e8",
bottomright="#5ac8c8",
xlab="Habitat suitability",
ylab="Bioclimatic congruence")
# Get colour matrix with 5 quantiles and legend. Specify the number of quantiles, colours and   # labels of the colour legend.
col.matrix<-colmat(nquantiles=5,
upperleft="#be64ac",
upperright="#3b4994",
bottomleft="#e8e8e8",
bottomright="#5ac8c8",
xlab="Habitat suitability",
ylab="Bioclimatic congruence")
colmat<-function(nquantiles=10, upperleft="#be64ac", upperright="#3b4994", bottomleft="#e8e8e8", bottomright="#5ac8c8", xlab="x label", ylab="y label"){
my.data<-seq(0,1,.01)
my.class<-classInt::classIntervals(my.data,n=nquantiles,style="quantile")
my.pal.1<-findColours(my.class,c(upperleft,bottomleft))
my.pal.2<-findColours(my.class,c(upperright, bottomright))
col.matrix<-matrix(nrow = 101, ncol = 101, NA)
for(i in 1:101){
my.col<-c(paste(my.pal.1[i]),paste(my.pal.2[i]))
col.matrix[102-i,]<-findColours(my.class,my.col)}
plot(c(1,1),pch=19,col=my.pal.1, cex=0.5,xlim=c(0,1),ylim=c(0,1),frame.plot=F, xlab=xlab, ylab=ylab,cex.lab=1.3)
for(i in 1:101){
col.temp<-col.matrix[i-1,]
points(my.data,rep((i-1)/100,101),pch=15,col=col.temp, cex=1)}
seqs<-seq(0,100,(100/nquantiles))
seqs[1]<-1
col.matrix<-col.matrix[c(seqs), c(seqs)]}
# Get colour matrix with 5 quantiles and legend. Specify the number of quantiles, colours and   # labels of the colour legend.
col.matrix<-colmat(nquantiles=5,
upperleft="#be64ac",
upperright="#3b4994",
bottomleft="#e8e8e8",
bottomright="#5ac8c8",
xlab="Habitat suitability",
ylab="Bioclimatic congruence")
colmat<-function(nquantiles=10, upperleft="#be64ac", upperright="#3b4994", bottomleft="#e8e8e8", bottomright="#5ac8c8", xlab="x label", ylab="y label"){
my.data<-seq(0,1,.01)
my.class<-classInt::classIntervals(my.data,n=nquantiles,style="quantile")
my.pal.1<-classInt::findColours(my.class,c(upperleft,bottomleft))
my.pal.2<-classInt::findColours(my.class,c(upperright, bottomright))
col.matrix<-matrix(nrow = 101, ncol = 101, NA)
for(i in 1:101){
my.col<-c(paste(my.pal.1[i]),paste(my.pal.2[i]))
col.matrix[102-i,]<-classInt::findColours(my.class,my.col)}
plot(c(1,1),pch=19,col=my.pal.1, cex=0.5,xlim=c(0,1),ylim=c(0,1),frame.plot=F, xlab=xlab, ylab=ylab,cex.lab=1.3)
for(i in 1:101){
col.temp<-col.matrix[i-1,]
points(my.data,rep((i-1)/100,101),pch=15,col=col.temp, cex=1)}
seqs<-seq(0,100,(100/nquantiles))
seqs[1]<-1
col.matrix<-col.matrix[c(seqs), c(seqs)]}
# Get colour matrix with 5 quantiles and legend. Specify the number of quantiles, colours and   # labels of the colour legend.
col.matrix<-colmat(nquantiles=5,
upperleft="#be64ac",
upperright="#3b4994",
bottomleft="#e8e8e8",
bottomright="#5ac8c8",
xlab="Habitat suitability",
ylab="Bioclimatic congruence")
bivariate.map<-function(rasterx, rastery, colormatrix=col.matrix, nquantiles=10){
quanmean<-getValues(rasterx)
temp<-data.frame(quanmean, quantile=rep(NA, length(quanmean)))
brks<-with(temp, quantile(temp,na.rm=TRUE, probs = c(seq(0,1,1/nquantiles))))
r1<-within(temp, quantile <- cut(quanmean, breaks = brks, labels = 2:length(brks),include.lowest = TRUE))
quantr<-data.frame(r1[,2])
quanvar<-getValues(rastery)
temp<-data.frame(quanvar, quantile=rep(NA, length(quanvar)))
brks<-with(temp, quantile(temp,na.rm=TRUE, probs = c(seq(0,1,1/nquantiles))))
r2<-within(temp, quantile <- cut(quanvar, breaks = unique(brks), labels = 2:length(unique(brks)),include.lowest = TRUE))
quantr2<-data.frame(r2[,2])
as.numeric.factor<-function(x) {as.numeric(levels(x))[x]}
col.matrix2<-col.matrix
cn<-unique(col.matrix)
for(i in 1:length(col.matrix2)){
ifelse(is.na(col.matrix2[i]),col.matrix2[i]<-1,col.matrix2[i]<-which(col.matrix2[i]==cn)[1])}
cols<-numeric(length(quantr[,1]))
for(i in 1:length(quantr[,1])){
a<-as.numeric.factor(quantr[i,1])
b<-as.numeric.factor(quantr2[i,1])
cols[i]<-as.numeric(col.matrix2[b,a])}
r<-rasterx
r[1:length(r)]<-cols
return(r)}
bivmap<-bivariate.map(suitability,congruencer,colormatrix=col.matrix, nquantiles=5)
bivmap
plot(bivmap,frame.plot=F,axes=F,box=F,add=F,legend=F,col=as.vector(col.matrix))
pocc <- terra::rast(x = 'data/processed/model-build/predictions/predictions.present-all-algorithms.tif') # remember to read with terra:: to retain layer names
pocc <- raster::stack(pocc) # and then turn them into RasterStacks
m_occ <- sdm::read.sdm("data/processed/model-build/model-object/model.sdm")
colmat<-function(nquantiles=10, upperleft="#be64ac", upperright="#3b4994", bottomleft="#e8e8e8", bottomright="#5ac8c8", xlab="x label", ylab="y label"){
my.data<-seq(0,1,.01)
my.class<-classInt::classIntervals(my.data,n=nquantiles,style="quantile")
my.pal.1<-classInt::findColours(my.class,c(upperleft,bottomleft))
my.pal.2<-classInt::findColours(my.class,c(upperright, bottomright))
col.matrix<-matrix(nrow = 101, ncol = 101, NA)
for(i in 1:101){
my.col<-c(paste(my.pal.1[i]),paste(my.pal.2[i]))
col.matrix[102-i,]<-classInt::findColours(my.class,my.col)}
plot(c(1,1),pch=19,col=my.pal.1, cex=0.5,xlim=c(0,1),ylim=c(0,1),frame.plot=F, xlab=xlab, ylab=ylab,cex.lab=1.3)
for(i in 1:101){
col.temp<-col.matrix[i-1,]
points(my.data,rep((i-1)/100,101),pch=15,col=col.temp, cex=1)}
seqs<-seq(0,100,(100/nquantiles))
seqs[1]<-1
col.matrix<-col.matrix[c(seqs), c(seqs)]}
# Get colour matrix with 5 quantiles and legend. Specify the number of quantiles, colours and   # labels of the colour legend.
col.matrix<-colmat(nquantiles=5,
upperleft="#be64ac",
upperright="#3b4994",
bottomleft="#e8e8e8",
bottomright="#5ac8c8",
xlab="Habitat suitability",
ylab="Bioclimatic congruence")
data("congruence")
plot(congruence,col=as.vector(col.matrix))
pocc <- terra::rast(x = 'data/processed/model-build/predictions/predictions.present-all-algorithms.tif') # remember to read with terra:: to retain layer names
pocc <- raster::stack(pocc) # and then turn them into RasterStacks
m_occ <- sdm::read.sdm("data/processed/model-build/model-object/model.sdm")
sdm_to_consistency(pocc,1)
knitr::include_graphics(here::here("figures", "README-congruence.png"))
knitr::include_graphics(here::here("man/figures", "README-congruence.png"))
knitr::include_graphics("man/figures", "README-congruence.png")
knitr::include_graphics("man/figures/README-congruence.png")
install.packages('bookdown')
# Load Data #####
## Environmental Data #####
envpres <- dir(path = 'data/processed/envcropped/Present/', pattern = ".tif$", full.names = T)
envpres <- raster::stack(envpres)
## Occurrence Data #####
occ_train <- rgdal::readOGR('data/processed/shapefiles/train.shp') # only presence data, dropping absences
occ_test <- rgdal::readOGR('data/processed/shapefiles/test.shp')
# sdm::installAll()
library(raster)
envpres <- as.data.frame(envpres)
# Prepare the data:
d_occ <- sdmData(formula = charinus~.,
train=occ_train, test = occ_test, predictors = envpres,
bg = 18, method = 'eRandom') # Create sdmData object
# Libs #####
# remotes::install_github(babaknaimi/sdm)
library(sdm)
# Prepare the data:
d_occ <- sdmData(formula = charinus~.,
train=occ_train, test = occ_test, predictors = envpres,
bg = 18, method = 'eRandom') # Create sdmData object
# Load Data #####
## Environmental Data #####
envpres <- dir(path = 'data/processed/envcropped/Present/', pattern = ".tif$", full.names = T)
envpres <- raster::stack(envpres)
envpres <- raster::as.data.frame(envpres)
# Prepare the data:
d_occ <- sdmData(formula = charinus~.,
train=occ_train, test = occ_test, predictors = envpres,
bg = 18, method = 'eRandom') # Create sdmData object
knitr::include_graphics("inst/figures/README-congruence.png")
knitr::include_graphics("man/figures/README-congruence.png")
knitr::include_graphics2("man/figures/README-congruence.png")
knitr::include_graphics("man/figures/README-congruence.png")
